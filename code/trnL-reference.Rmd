---
title: "trnL reference"
author: "brianna petrone"
output: html_document
---

# Setup 
### Packages and functions
```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = file.path(getwd(), '..'))
```

```{r}
library(Biostrings)
library(here)
library(ShortRead) # for clean()
library(tidyverse)

source(here('code', 'functions', 'find_primer_pair.R'))
source(here('code', 'functions', 'get_binomial.R'))
source(here('code', 'functions', 'query_ncbi.R'))
```

### Primer sequences
```{r}
trnLG <- DNAString('GGGCAATCCTGAGCCAA')
trnLH <- DNAString('CCATTGAGTCTCTGCACCTATC')

primers <- list(trnLG, trnLH)
```

### Dietary plants
```{r}
plants <- 
     # here('data', 'raw', 'human-foods.csv') %>% 
     here('data', 'raw', 'human-foods-update.csv') %>% 
     read.csv(stringsAsFactors = FALSE) %>%
     filter(category == 'plant') %>% 
     pull(scientific_name)

head(plants)
```

# Compile reference sequences

## RefSeq plastid database

Downloaded from RefSeq FTP site on 6/1/2021.
```{r}
fs <- 
     here('data', 'raw', 'organelles', 'refseq_plastid') %>% 
     list.files(full.names = TRUE)

basename(fs)

plastid <- 
     c(readDNAStringSet(fs[1]), 
       readDNAStringSet(fs[2]),
       readDNAStringSet(fs[3]),
       readDNAStringSet(fs[4]))

plastid
```

```{r}
# Could remove this code and rename using accession number query as below
head(names(plastid))

# Simplify naming from current
names(plastid) <- 
     names(plastid) %>%
     str_split(' chloroplast| plastid| apicoplast| plastome| genome') %>% 
     lapply('[[', 1) %>% 
     unlist()

names(plastid) <- 
     names(plastid) %>%
     str_split(' voucher| isolate| culture| genotype| clone| ecotype') %>% 
     lapply('[[', 1) %>% 
     unlist()

names(plastid) <- 
     names(plastid) %>%
     str_split(' complete') %>% 
     lapply('[[', 1) %>% 
     unlist()

# Cultivar information not included in NCBI taxonomy look-up, and we could still pull this from accession number if desired
names(plastid) <- 
     names(plastid) %>%
     str_split(' cultivar| strain') %>% 
     lapply('[[', 1) %>% 
     unlist()

head(names(plastid))
```

```{r}
# Peek at any names that aren't binomial
names(plastid)[grep('(\\S+\\s){3,}', # More than 3 words
                    names(plastid))]
```


```{r}
# Are any names duplicated?
any(duplicated(names(plastid)))
```

```{r}
# Write to file
# writeXStringSet(plastid,
#                 here('data', 'processed', 'parsed-refs', 'RefSeq',
#                      'refseq_plastid_species.fasta'))
```

### Find primer binding sites

```{r}
# Note this discrepancy-- could potentially do better screening of these sequences.  Worried that I am tossing things for Ns that occur nowhere near trnL-P6
length(plastid)
length(clean(plastid))
```

```{r}
refseq.trnL <- find_primer_pair(plastid, 
                                fwd = primers[[1]],
                                rev = primers[[2]])

cat(length(refseq.trnL), 'sequences have the primer set')
```

5290 from cleaned data

### Subset by food species

```{r}
# Find indices of entries matching 
plants.i <- 
     lapply(plants, grep, x = names(refseq.trnL)) %>%
     unlist()

cat('There are', length(plants), 'food plants in our query\n')

# Subset
refseq.trnL <- refseq.trnL[plants.i]
cat(length(refseq.trnL), 'have a trnL sequence in the RefSeq plastid database')
```

## NCBI

### Pull sequences

```{r}
# Pull sequences from NCBI
ncbi.trnL <- query_ncbi(marker = 'trnL',
                        # organisms = plants.missing)
                        organisms = plants)
```

This is from the total number of available sequences

```{r}
length(ncbi.trnL)
length(clean(ncbi.trnL))
```

### Find primers
Now look for primer binding sites within retrieved sequences.
Have now addressed 

```{r}
ncbi.trnL <- find_primer_pair(ncbi.trnL, 
                              fwd = primers[[1]],
                              rev = primers[[2]])

cat(length(ncbi.trnL), 'sequences have the primer set')
```

2996 from cleaned data, 2997 from sequences containing Ns. 

```{r}
# Inspect names
data.frame(names(ncbi.trnL))
```
```{r}
# Note some entries are marked as unverified
names(ncbi.trnL)[grepl('UNVERIFIED', names(ncbi.trnL))]
```

```{r}
# Remove these
length(ncbi.trnL)
ncbi.trnL <- ncbi.trnL[!(grepl('UNVERIFIED', names(ncbi.trnL)))]
length(ncbi.trnL)
```

### Tidy names

Lots of variation in descriptors.  Try pulling taxon name by NCBI query of accession number

```{r}
accs <- 
     names(ncbi.trnL) %>% 
     str_split(pattern = '\\s') %>% 
     lapply('[[', 1) %>% 
     unlist() %>% 
     gsub(pattern = '>', replacement = '')

head(accs)
```

```{r}
# Look up accession taxonomy with taxa package functions
# Note-- this takes a long time depending on # of sequence IDs
taxmap <- taxa::lookup_tax_data(accs, 
                                type = 'seq_id')
```

```{r}
str(taxmap$data)
```

```{r}
# Want to combine these two, to get name for each query id
# Get query info
query_names <- 
     data.frame(acc = taxmap$data$query_data,
                taxon_id = names(taxmap$data$query_data))

# Join to NCBI names
ncbi_names <- taxmap$data$tax_data

query_names <- 
     left_join(query_names, ncbi_names)

query_names
```

```{r}
# Any names missing?
any(is.na(query_names$ncbi_name))
```

```{r}
# How complete are entries?
query_names %>% 
     group_by(ncbi_rank) %>% 
     count()
```

```{r}
# Hmmm-- what's this forma and no rank?
query_names %>% 
     filter(ncbi_rank %in% c('forma', 'no rank'))
```
```{r}
# Rename sequences
names(ncbi.trnL) <- paste(query_names$acc,
                          query_names$ncbi_name)
```

## Combine

### Check overlap

```{r}
length(refseq.trnL)
length(ncbi.trnL)
```

```{r}
# Data frame of results
seqs.df <- 
     data.frame(source = 'RefSeq',
                name = names(refseq.trnL),
                seq = as.character(refseq.trnL))

seqs.df <- 
     data.frame(source = 'GenBank',
                name = names(ncbi.trnL),
                seq = as.character(ncbi.trnL)) %>% 
     bind_rows(seqs.df)

head(seqs.df)
```
```{r}
# Clean up name
seqs.df <- 
     seqs.df %>% 
     separate(name, 
              into = c('acc', 'taxon'),
              sep = ' ',
              extra = 'merge',
              remove = FALSE)
```

```{r}
# Compare
# How many unique sequences?
seqs.df %>% 
     group_by(source) %>% 
     summarize(total = length(seq),
               unique = n_distinct(seq))
```

```{r}
# How many unique species?
seqs.df %>% 
     group_by(source) %>% 
     summarize(total = length(taxon),
               unique = n_distinct(taxon))
```
```{r}
# What's the intersection between taxa in each set?
gb.taxa <- 
     seqs.df %>% 
     filter(source == 'GenBank') %>% 
     pull(taxon) %>% 
     unique()

refseq.taxa <- 
     seqs.df %>% 
     filter(source == 'RefSeq') %>% 
     pull(taxon) %>% 
     unique()
```

```{r}
intersect(gb.taxa, refseq.taxa) %>% 
     length()
```

```{r}
# In RefSeq, but not NCBI
setdiff(refseq.taxa, gb.taxa) %>% 
     length()
```

```{r}
# In NCBI, but not RefSeq
setdiff(gb.taxa, refseq.taxa) %>% 
     length()
```

What's weird here is that the nucleotide database should *include* RefSeq, so I don't know why I'm pulling some things out but not others.

How many of initial query not found?

```{r}
missing <- plants[!(plants %in% seqs.df$taxon)]
length(plants)
length(missing)
```

### Merge

#### QC

Check for common errors

```{r}
any(duplicated(seqs.df$ID))
```

```{r}
# Check for degenerate nucleotide characters
grep('[AGCT]*[^AGCT]+', seqs.df$seq)
```

```{r}
# Add a flag to these taxa, to see if there's a back-up sequence
seqs.df$N <- grepl('[AGCT]*[^AGCT]+', seqs.df$seq)

with_n <- 
     seqs.df$taxon[grepl('[AGCT]*[^AGCT]+', seqs.df$seq)] %>% 
     unique()
```

```{r}
seqs.df %>% 
     filter(taxon %in% with_n) %>% 
     group_by(taxon, N) %>% 
     count() %>% 
     ungroup() %>% 
     group_by(taxon) %>% 
     summarize(any(!N))
```
Okay, so for all taxa but
- Amaranthus cruentus
- Amaranthus dubius
- Amaranthus tricolor
- Vaccinium tenellum

we are covered by a second sequence. 

```{r}
# Remove sequences containing Ns
seqs.df <- 
     filter(seqs.df,
            !grepl(pattern = '[AGCT]*[^AGCT]+', seq))
```

### Clean results
* Sequences that are the same and that come from the same species can be de-duplicated
* Sequences that are different and come from the same species must be preserved

```{r}
seqs.df %>% 
     group_by(taxon, seq)
```
```{r}
dups <- 
     seqs.df %>% 
     group_by(taxon) %>% 
     summarize(n = sum(duplicated(seq)))

arrange(dups, desc(n))
```
```{r}
sum(dups$n)
```

So the number of sequences we expect after filtering is 
```{r}
dim(seqs.df)[1] - sum(dups$n)
```

```{r}
seqs.df <- 
     seqs.df %>%
     group_by(taxon, seq) %>% 
     arrange(acc) %>% 
     summarize(acc = first(acc)) # Choose the first accession number

dim(seqs.df)
```

```{r}
# Sort alphabetically (first by species name, and then accession number)
seqs.df <- arrange(seqs.df, 
                   taxon,
                   acc)

# Convert back to DNAStringSet object
trnL <- seqs.df$seq
names(trnL) <- paste(seqs.df$acc, seqs.df$taxon)

trnL <- DNAStringSet(trnL)
trnL
```

```{r}
# Save to file
# Consider updating name below so I can compare to prior file
# writeXStringSet(trnL,
#                 here('data',
#                      'processed',
#                      'dada2-compatible',
#                      'trnL',
#                      'trnLGH.fasta'))
```

# Compare to prior

```{r}
prior <- 
     readDNAStringSet(
          here('data', 
               'processed',
               'dada2-compatible',
               'trnL',
               'trnLGH.fasta')
     )
```

```{r}
# Convert to dataframe representation as above
seqs.prior <- 
     data.frame(name = names(prior),
                seq = as.character(prior)) %>% 
     separate(name,
              into = c('accession', 'name'),
              sep = ' ',
              extra = 'merge') 

row.names(seqs.prior) <- NULL
```

```{r}
# How many species by number?
n_distinct(seqs.prior$name)
n_distinct(seqs$name)
```


```{r}
# Add flag for distinguishing origin
seqs$current = 1
seqs.prior$prior = 1

seqs <- rename(seqs, seq_current = seq)
seqs.prior <- rename(seqs.prior, seq_prior = seq)

seqs.compare <- 
     full_join(
          select(seqs, -accession),
          select(seqs.prior, -accession)
     ) %>% 
     select(name, 
            prior, 
            current,
            seq_prior,
            seq_current)
```

```{r}
# How many are exactly the same?
intersect(
     paste(seqs$name, seqs$seq_current),
     paste(seqs.prior$name, seqs.prior$seq_prior)
) %>% 
     length()
```

```{r}
# What species 
filter(seqs.compare, 
       prior == 1 & current == 1) %>% 
     dim()
```

```{r}
# Any represented in prior but not in current?
filter(seqs.compare, 
       prior == 1 & is.na(current)) 
```

