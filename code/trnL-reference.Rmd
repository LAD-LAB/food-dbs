---
title: "trnL reference"
output: 
     html_document:
          df_print: paged
          toc: true
          toc_float: true
---

Stepping through this notebook will build a *trnL* reference database, trimmed to sequences amplified by the desired primer set (here, *trnL*g and *trnL*h).

This notebook use 

```{r libraries, include=FALSE, echo=FALSE}
library(Biostrings)
library(here)
library(ShortRead) # for clean()
library(taxonomizr) # for NCBI accession lookup
library(tidyverse)

source(here('code', 'functions', 'find_primer_pair.R'))
source(here('code', 'functions', 'get_binomial.R'))
source(here('code', 'functions', 'query_ncbi.R'))
```

```{r plotting, include=FALSE, echo=FALSE}
theme_set(theme_bw() +
               theme(
                    axis.text = element_text(size = 12),
                    axis.title = element_text(size = 14,
                                              face = 'bold'),
                    legend.title = element_text(size = 12,
                                                face = 'bold'),
                    strip.text = element_text(size = 12,
                                              face = 'bold')
                     )
)
```

## Read in data 

```{r}
# Primer sequences 
trnLG <- DNAString('GGGCAATCCTGAGCCAA')
trnLH <- DNAString('CCATTGAGTCTCTGCACCTATC')

primers <- list(trnLG, trnLH)
```

### Dietary plants

```{r}
# Manually curated list of dietary and medicinal plants
plants <- 
     here('data', 'inputs', 'human-foods.csv') %>%
     read.csv(stringsAsFactors = FALSE) %>%
     filter(category == 'plant') %>% 
     pull(scientific_name)

length(plants)
head(plants)
tail(plants)
```
We'll Downloaded from RefSeq FTP site on 6/1/2021.
```{r}
# RefSeq plastid database
fs <- 
     here('data', 
          'inputs', 
          'organelles',
          'refseq_plastid') %>% 
     list.files(full.names = TRUE,
                pattern = 'fna.gz$')

basename(fs)

plastid <- 
     lapply(fs, readDNAStringSet) %>% 
     do.call(c, .)

plastid
```

```{r}
# Could remove this code and rename using accession number query as below
head(names(plastid))

# Simplify naming from current
names(plastid) <- 
     names(plastid) %>%
     str_split(' chloroplast| plastid| apicoplast| plastome| genome') %>% 
     lapply('[[', 1) %>% 
     unlist()

names(plastid) <- 
     names(plastid) %>%
     str_split(' voucher| isolate| culture| genotype| clone| ecotype| bio-material') %>% 
     lapply('[[', 1) %>% 
     unlist()

names(plastid) <- 
     names(plastid) %>%
     str_split(' complete') %>% 
     lapply('[[', 1) %>% 
     unlist()

# Cultivar information not included in NCBI taxonomy look-up, and we could still pull this from accession number if desired
names(plastid) <- 
     names(plastid) %>%
     str_split(' cultivar| strain') %>% 
     lapply('[[', 1) %>% 
     unlist()

head(names(plastid))
```

```{r}
# Peek at any names that aren't binomial
names(plastid)[grep('(\\S+\\s){3,}', # More than 3 words
                    names(plastid))]
```

```{r}
# Are any names duplicated?
any(duplicated(names(plastid)))
```

```{r}
# Write to file
writeXStringSet(plastid,
                here('data', 
                     'outputs', 
                     'parsed-refs',
                     'RefSeq',
                     'refseq_plastid_species.fasta'))
```

### Find primers

```{r}
# Note this discrepancy-- could potentially do better screening of these sequences.  Worried that I am tossing things for Ns that occur nowhere near trnL-P6
length(plastid)
length(clean(plastid))
```

```{r}
refseq.trnL <- find_primer_pair(plastid, 
                                fwd = primers[[1]],
                                rev = primers[[2]])

cat(length(refseq.trnL), 'sequences have the primer set')
```

### Subset to foods

Just doing this by a simple grep for now
Could imagine it would be cleaner to process RefSeq to a comparable name as in our query
Keep accessions from raw files, look up taxonomy, then assign a "lowest level" name that would correspond to entries in human-foods.txt.

```{r}
# Find indices of entries matching 
plants.i <- 
     lapply(plants, grep, x = names(refseq.trnL)) %>%
     unlist()

cat('There are', length(plants), 'food plants in our query\n')

# Subset
refseq.trnL <- refseq.trnL[plants.i]
cat(length(refseq.trnL), 'have a trnL sequence in the RefSeq plastid database')
```

```{r}
# Strip name to only NCBI accession
names(refseq.trnL) %>% head()

names(refseq.trnL) <- 
     gsub(names(refseq.trnL),
     pattern = ' .+$',
     replacement = '')

head(names(refseq.trnL))
```

## NCBI

### Pull sequences

```{r}
# Pull sequences from NCBI
ncbi.trnL <- query_ncbi(marker = 'trnL',
                        # organisms = plants.missing)
                        organisms = plants)
```

This is from the total number of available sequences

```{r}
length(ncbi.trnL)
length(clean(ncbi.trnL))
```

### Find primers
Now look for primer binding sites within retrieved sequences.
Have now addressed 

```{r}
ncbi.trnL <- find_primer_pair(ncbi.trnL, 
                              fwd = primers[[1]],
                              rev = primers[[2]])

cat(length(ncbi.trnL), 'sequences have the primer set')
```

```{r}
# Inspect names
data.frame(names(ncbi.trnL))
```
```{r}
# Note some entries are marked as unverified
names(ncbi.trnL)[grepl('UNVERIFIED', names(ncbi.trnL))]
```

```{r}
# Remove these
length(ncbi.trnL)
ncbi.trnL <- ncbi.trnL[!(grepl('UNVERIFIED', names(ncbi.trnL)))]
length(ncbi.trnL)
```

```{r}
# Strip name to only NCBI accession
names(ncbi.trnL) %>% head()
names(ncbi.trnL) <- 
     names(ncbi.trnL) %>% 
     gsub(pattern = ' .+$', replacement = '') %>% 
     gsub(pattern = '^>', replacement = '')

head(names(ncbi.trnL))
```
#  Tidy names

```{r}
accs <- c(names(refseq.trnL),
          names(ncbi.trnL))

head(accs)
length(accs)
```

```{r}
# Look up accession taxonomy using taxonomizr-formatted SQL database
# Need to have Isilon network drive mapped-- this is where database (70 Gb) currently stored
# This takes a few minutes
sql <- '/Volumes/All_Staff/localreference/ncbi_taxonomy/accessionTaxa.sql'
ids <- taxonomizr::accessionToTaxa(accs, sql)
```

```{r}
# Any names missing?
any(is.na(ids))
sum(is.na(ids))
```

```{r}
# Which ones?
accs[is.na(ids)]
```

Wow that's amazing-- think this is literally the gap between when I made database until now

NC_070364.1 Physalis philadelphica (tomatillo) chloroplast, uploaded 1/26/2023
ON054983.1 Parkia speciosa (bitter bean) 1/22/2023
ON054982.1 "
ON054979.1 Solanum torvum (turkey berry) 1/22/2023
ON054978.1 "
ON054977.1 "
ON054972.1 Solanum lasiocarpum 1/22/2023
ON054971.1 "
ON054970.1 "
ON054969.1 "
ON054968.1 "

```{r}
# Remove these before proceeding
accs <- accs[!is.na(ids)]
ids <- ids[!is.na(ids)]
```

```{r}
taxonomy.raw <- 
     taxonomizr::getRawTaxonomy(ids, sql)
```

```{r}
# Pull desired levels from this structure
# Not working within getTaxonomy function
vars <- c("superkingdom", 
          "phylum", 
          "class", 
          "order", 
          "family", 
          "genus",
          "species",
          "subspecies",
          "varietas",
          "forma")

taxonomy <- data.frame(superkingdom = NULL,
                       phylum = NULL,
                       class = NULL,
                       order = NULL,
                       family = NULL,
                       genus = NULL,
                       species = NULL,
                       subspecies = NULL,
                       varietas = NULL,
                       forma = NULL)

for (i in seq_along(taxonomy.raw)){
     row.i <- 
          taxonomy.raw[[i]] %>% 
          t() %>% 
          data.frame() 
     
     # Pick columns we're interested in
     shared <- intersect(vars, names(row.i))
     row.i <- select(row.i, one_of(shared))
     
     taxonomy <- bind_rows(taxonomy, row.i)
}

# Add taxon ID
taxonomy$taxid <- 
     names(taxonomy.raw) %>% 
     trimws() %>% 
     as.integer()

taxonomy <- select(taxonomy, taxid, everything())
```

```{r}
head(taxonomy)
```

```{r}
# Join back to accession
dim(taxonomy)
taxonomy <- 
     data.frame(accession = accs,
                taxid = ids) %>% 
     full_join(distinct(taxonomy))
dim(taxonomy)
```

## Combine

### Check overlap

```{r}
length(refseq.trnL)
length(ncbi.trnL)
```

```{r}
# Data frame of results
seqs.df <- 
     data.frame(source = 'RefSeq',
                accession = names(refseq.trnL),
                seq = as.character(refseq.trnL))

seqs.df <- 
     data.frame(source = 'GenBank',
                accession = names(ncbi.trnL),
                seq = as.character(ncbi.trnL)) %>% 
     bind_rows(seqs.df)

head(seqs.df)
```

```{r}
# Re-name with lowest-level taxon
taxonomy <- MButils::lowest_level(taxonomy)
seqs.df <- 
     seqs.df %>% 
     left_join(select(taxonomy, accession, taxon = name)) 
```

```{r}
# Compare
# How many unique sequences?
seqs.df %>% 
     group_by(source) %>% 
     summarize(total = length(seq),
               unique = n_distinct(seq))
```

```{r}
# How many unique species?
seqs.df %>% 
     group_by(source) %>% 
     summarize(total = length(taxon),
               unique = n_distinct(taxon))
```
```{r}
# Plot this
seqs.df %>% 
     group_by(source) %>% 
     summarize(across(.cols = c(taxon, seq),
                      .fns = list(total=length, 
                                  unique=n_distinct))) %>% 
     pivot_longer(-source,
                  names_to = 'unit',
                  values_to = 'value') %>% 
     separate(unit,
              into = c('unit', 'type'),
              sep = '_') %>% 
     mutate(unit = factor(unit,
                          levels = c('taxon', 'seq'),
                          labels = c('Taxa', 'Sequences')),
            source = factor(source,
                            levels = c('RefSeq', 'GenBank')),
            type = str_to_title(type)) %>% 
     ggplot(aes(x = source, y = value, fill = type)) +
          geom_bar(stat = 'identity',
                   position = 'dodge') +
     facet_wrap(~unit) +
     labs(y = 'Count') +
     scale_fill_manual(values = c('#6b6b6b', '#91b3d7')) +
     theme(axis.title.x = element_blank(),
           legend.title = element_blank())
```
```{r}
plotID <- paste(Sys.Date(), as.character(sample(000:999,1)), sep=".")
# ggsave(here('results',
#             'Total and unique contributions by source.pdf'),
#        height = 3, width = 5)
```

```{r}
# What's the intersection between taxa in each set?
gb.taxa <- 
     seqs.df %>% 
     filter(source == 'GenBank') %>% 
     pull(taxon) %>% 
     unique()

refseq.taxa <- 
     seqs.df %>% 
     filter(source == 'RefSeq') %>% 
     pull(taxon) %>% 
     unique()
```

```{r}
# Make dataframe for plot input
db.df <- 
     data.frame(taxon = unique(seqs.df$taxon)) %>% 
     mutate(RefSeq = taxon %in% refseq.taxa,
            GenBank = taxon %in% gb.taxa)

head(db.df)
```

```{r}
# Version with labels for reference
eulerr::euler(db.df[,c('RefSeq', 'GenBank')]) %>% 
     plot(
          fills = c('#e15759', 'white'),
          labels = FALSE,
          shape = "ellipse", 
          quantities = TRUE
     )
```
```{r}
plotID <- paste(Sys.Date(), as.character(sample(000:999,1)), sep=".")
# pdf(here('results',
#          paste0(plotID,
#                 '_Taxon contributions of RefSeq and GenBank.pdf')),
#     height = 3, width = 3)
```


What's weird here is that the nucleotide database should *include* RefSeq, so I don't know why I'm pulling some things out but not others.

How many of initial query not found?

```{r}
missing <- plants[!(plants %in% seqs.df$taxon)]
length(plants)
length(missing)
```

### Merge

#### QC

Check for common errors

```{r}
# Check for degenerate nucleotide characters
grep('[AGCT]*[^AGCT]+', seqs.df$seq)
```

```{r}
# Add a flag to these taxa, to see if there's a back-up sequence
seqs.df$N <- grepl('[AGCT]*[^AGCT]+', seqs.df$seq)

with_n <- 
     seqs.df$taxon[grepl('[AGCT]*[^AGCT]+', seqs.df$seq)] %>% 
     unique()
```

```{r}
seqs.df %>% 
     filter(taxon %in% with_n) %>% 
     group_by(taxon, N) %>% 
     count() %>% 
     ungroup() %>% 
     group_by(taxon) %>% 
     summarize(any(!N))
```
Okay, so for all taxa but
- Amaranthus cruentus
- Amaranthus dubius
- Costus erythrophyllus
- Vaccinium tenellum
- Victoria amazonica

we are covered by a second sequence. 

```{r}
# Remove sequences containing Ns
seqs.df <- 
     filter(seqs.df,
            !grepl(pattern = '[AGCT]*[^AGCT]+', seq))
```

####  Get reads in same orientation

```{r}
# Get orientation of sequence by finding primers
# How many mismatches are allowed?
fwd_err <- floor(0.2*length(trnLG))
rev_err <- floor(0.2*length(trnLH))

fwd_err
rev_err
```

```{r}
ref <- DNAStringSet(seqs.df$seq)
names(ref) <- paste(seqs.df$accession, seqs.df$taxon)
```

```{r}
# Forward primer at start of read
fwd_matches <- 
     vmatchPattern(trnLG, 
                   ref, 
                   max.mismatch = fwd_err,
                   fixed = TRUE) %>%
     as.data.frame() %>% 
     filter(start <= 1) %>% 
     mutate(type = 'forward') %>% 
     select(group, type)

# Reverse primer at start of read
rev_matches <- 
     vmatchPattern(trnLH, 
                   ref, 
                   max.mismatch = rev_err,
                   fixed = TRUE) %>%
     as.data.frame() %>% 
     filter(start <= 1) %>% 
     mutate(type = 'reverse') %>% 
     select(group, type)
```

```{r}
nrow(rev_matches) + nrow(fwd_matches) == nrow(seqs.df)
```

```{r}
seqs.df <- 
     bind_rows(fwd_matches,
          rev_matches) %>% 
     arrange(group) %>% 
     bind_cols(seqs.df)

seqs.df %>% 
     group_by(type) %>% 
     count()
```
Now, if a read is reversed, we want to replace it with its reverse complement
```{r}
seqs.df <- 
     mutate(seqs.df,
            seq = ifelse(type == 'reverse',
                         yes = seq %>% 
                              DNAStringSet() %>% 
                              reverseComplement() %>% 
                              as.character(),
                         no = seq)) %>% 
     select(-c(type, group))
```

#### Clean results

* Sequences that are the same and that come from the same species can be de-duplicated
* Sequences that are different and come from the same species must be preserved

```{r}
seqs.df %>% 
     group_by(taxon, seq)
```
```{r}
dups <- 
     seqs.df %>% 
     group_by(taxon) %>% 
     summarize(n = sum(duplicated(seq)))

arrange(dups, desc(n))
```
```{r}
sum(dups$n)
```

So the number of sequences we expect after filtering is 
```{r}
dim(seqs.df)[1] - sum(dups$n)
```

```{r}
seqs.df <- 
     seqs.df %>%
     group_by(taxon, seq) %>% 
     arrange(acc) %>% 
     summarize(acc = first(acc)) # Choose the first accession number

dim(seqs.df)
```

## Get taxonomy

### Taxonomy

```{r}
ids <- taxonomizr::accessionToTaxa(seqs.df$acc, sql)
```

```{r}
# Get last common ancestor of all matched taxonomic assignments
taxonomy.raw <- 
     taxonomizr::getRawTaxonomy(ids, sql)
```

```{r}
# Pull desired levels from this structure
# Not working within getTaxonomy function
vars <- c("superkingdom", 
          "phylum", 
          "class", 
          "order", 
          "family", 
          "genus",
          "species",
          "subspecies",
          "varietas",
          "forma")

taxonomy <- data.frame(superkingdom = NULL,
                       phylum = NULL,
                       class = NULL,
                       order = NULL,
                       family = NULL,
                       genus = NULL,
                       species = NULL,
                       subspecies = NULL,
                       varietas = NULL,
                       forma = NULL)

for (i in seq_along(taxonomy.raw)){
     row.i <- 
          taxonomy.raw[[i]] %>% 
          t() %>% 
          data.frame() 
     
     # Pick columns we're interested in
     shared <- intersect(vars, names(row.i))
     row.i <- select(row.i, one_of(shared))
     
     taxonomy <- bind_rows(taxonomy, row.i)
}

# Add taxon ID
taxonomy$taxid <- 
     names(taxonomy.raw) %>% 
     trimws() %>% 
     as.integer()

taxonomy <- select(taxonomy, taxid, everything())
```

```{r}
head(taxonomy)
```

```{r}
# Now join these to sequences
seqs.df <- bind_cols(seqs.df, taxonomy)
```

## Save

### DADA2
```{r}
# Sort alphabetically (first by species name, and then accession number)
seqs.df <- arrange(seqs.df, 
                   taxon,
                   acc)

# Convert back to DNAStringSet object
trnL <- seqs.df$seq
names(trnL) <- paste(seqs.df$acc, seqs.df$taxon)

trnL <- DNAStringSet(trnL)
trnL
```
```{r}
# Save to file
# Consider updating name below so I can compare to prior file
# writeXStringSet(trnL,
#                 here('data',
#                      'processed',
#                      'dada2-compatible',
#                      'trnL',
#                      'trnLGH.fasta'))
```

```{r}
seqs.df <- 
     seqs.df %>% 
     unite(col = 'name',
           superkingdom:forma,
           sep = ';') 

names(trnL) <- seqs.df$name
```

```{r}
# writeXStringSet(trnL,
#                 here('data',
#                      'outputs',
#                      'dada2-compatible',
#                      'trnL',
#                      'trnLGH_taxonomy.fasta'))
```

### QIIME2 

Taxonomic assignment in QIIME2 with `classify-consensus-vsearch` requires two files:
- `i-reference-reads`, a QIIME artifact containing a FASTA file of sequences identified by their accession
- `i-reference-taxonomy`, a QIIME artifact containing a TSV (tab-separated value) file with two columns: "Feature ID", the same accessions, and "Taxon", the taxonomic lineage with ranks separated by semicolons

```{r}
outdir <- here('data',
               'outputs',
               'qiime2-compatible')

Sys.setenv(QIIME2 = outdir)
```

Note that QIIME2 requires that the FASTA file have unique accessions, so make these unique before proceeding

```{r}
seqs.df <- mutate(seqs.df,
                  acc = make.unique(acc,
                                    sep = '_'))

names(trnL) <- seqs.df$acc
# writeXStringSet(trnL,
#                 file.path(outdir,
#                           'trnL-sequences.fasta'))
```

```{r}
# seqs.df %>%
#      select(`Feature ID` = acc,
#             Taxon = name) %>%
#      write_delim(delim = '\t',
#                  file.path(outdir,
#                            'trnL-taxonomy.tsv'))
```

```{bash engine.opts='-l'}
# Running this block requires a QIIME2 conda environment on local machine
# Note that yours may differ from the "qiime2-2022.8"; you can find correct name by running conda env list in the terminal
# Convert both of the above objects to QIIME2 artifacts (QZA)
cd "$QIIME2"
conda activate qiime2-2022.8 

qiime tools import \
     --input-path trnL-sequences.fasta \
     --output-path trnL-sequences.qza \
     --type 'FeatureData[Sequence]'
     
qiime tools import \
     --input-path trnL-taxonomy.tsv \
     --output-path trnL-taxonomy.qza \
     --type 'FeatureData[Taxonomy]'
```

