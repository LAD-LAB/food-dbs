---
title: "trnL reference"
author: "brianna petrone"
output: html_document
---

# Setup 
### Packages and functions
```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = file.path(getwd(), '..'))
```

```{r}
library(Biostrings)
library(here)
library(ShortRead) # for clean()
library(tidyverse)

source(here('code', 'functions', 'find_primer_pair.R'))
source(here('code', 'functions', 'get_binomial.R'))
source(here('code', 'functions', 'query_ncbi.R'))
```

### Primer sequences
```{r}
trnLG <- DNAString('GGGCAATCCTGAGCCAA')
trnLH <- DNAString('CCATTGAGTCTCTGCACCTATC')

primers <- list(trnLG, trnLH)
```

### Dietary plants
```{r}
plants <- 
     here('data', 'raw', 'human-foods.csv') %>% 
     read.csv(stringsAsFactors = FALSE) %>%
     filter(category == 'plant') %>% 
     pull(scientific_name)

head(plants)
```

# Compile reference sequences

## RefSeq plastid database

Downloaded from RefSeq FTP site on 6/1/2021.
```{r}
fs <- 
     here('data', 'raw', 'organelles', 'refseq_plastid') %>% 
     list.files(full.names = TRUE)

basename(fs)

plastid <- 
     c(readDNAStringSet(fs[1]), 
       readDNAStringSet(fs[2]),
       readDNAStringSet(fs[3]),
       readDNAStringSet(fs[4]))

plastid
```

```{r}
head(names(plastid))

# Simplify naming from current
names(plastid) <- 
     names(plastid) %>%
     str_split(' chloroplast| plastid| apicoplast| plastome| genome') %>% 
     lapply('[[', 1) %>% 
     unlist()

names(plastid) <- 
     names(plastid) %>%
     str_split(' voucher| isolate| culture| genotype| clone| ecotype') %>% 
     lapply('[[', 1) %>% 
     unlist()

names(plastid) <- 
     names(plastid) %>%
     str_split(' complete') %>% 
     lapply('[[', 1) %>% 
     unlist()

# Cultivar information not included in NCBI taxonomy look-up, and we could still pull this from accession number if desired
names(plastid) <- 
     names(plastid) %>%
     str_split(' cultivar| strain') %>% 
     lapply('[[', 1) %>% 
     unlist()

head(names(plastid))
```

```{r}
# Peek at any names that aren't binomial
names(plastid)[grep('(\\S+\\s){3,}', # More than 3 words
                    names(plastid))]
```


```{r}
# Are any names duplicated?
any(duplicated(names(plastid)))
```

```{r}
# Write to file
# writeXStringSet(plastid,
#                 here('data', 'processed', 'parsed-refs', 'RefSeq',
#                      'refseq_plastid_species.fasta'))
```

### Find primer binding sites

```{r}
# Note this discrepancy-- could potentially do better screening of these sequences.  Worried that I am tossing things for Ns that occur nowhere near trnL-P6
length(plastid)
length(clean(plastid))
```

```{r}
refseq.trnL <- find_primer_pair(clean(plastid), 
                                fwd = primers[[1]],
                                rev = primers[[2]])

cat(length(refseq.trnL), 'sequences have the primer set')
```

### Subset by food species

```{r}
# Find indices of entries matching 
plants.i <- 
     lapply(plants, grep, x = names(refseq.trnL)) %>%
     unlist()

cat('There are', length(plants), 'food plants in our query\n')

# Subset
refseq.trnL <- refseq.trnL[plants.i]
cat(length(refseq.trnL), 'have a trnL sequence in the RefSeq plastid database')
```

What foods are still missing?

```{r}
plants.refseq <- sub('\\S+\\s', '', names(refseq.trnL))

# Subset remaining foods based on this list
plants.missing <- 
     plants[lapply(plants,
                   function(x){length(grep(x, plants.refseq))}) == 0]

plants.missing
```

## NCBI

### Pull sequences

```{r}
# Pull sequences from NCBI
ncbi.trnL <- query_ncbi(marker = 'trnL',
                        organisms = plants.missing)
```

This is from the total number of available sequences

```{r}
length(ncbi.trnL)
length(clean(ncbi.trnL))
```

### Find primers
Now look for primer binding sites within retrieved sequences.
Note that current strategy to remove ambiguous nucleotides is problematic-- because a single ambiguous nucleotide far from the amplicon could lead to throwing away a usable sequence
TODO: Needs to be addressed in find_primer_pair.R

```{r}
ncbi.trnL <- find_primer_pair(clean(ncbi.trnL), 
                                 fwd = primers[[1]],
                                 rev = primers[[2]])

cat(length(ncbi.trnL), 'sequences have the primer set')
```

```{r}
# Inspect names
data.frame(names(ncbi.trnL))
```
```{r}
# Note some entries are marked as unverified
names(ncbi.trnL)[grepl('UNVERIFIED', names(ncbi.trnL))]
```

```{r}
# Remove these
length(ncbi.trnL)
ncbi.trnL <- ncbi.trnL[!(grepl('UNVERIFIED', names(ncbi.trnL)))]
length(ncbi.trnL)
```

### Tidy names

```{r}
# Remove trailing descriptors after species name
names(ncbi.trnL) <- 
     names(ncbi.trnL) %>%
     str_split(' chloroplast| plastid| apicoplast') %>% 
     lapply('[[', 1) %>% 
     unlist()

names(ncbi.trnL) <- 
     names(ncbi.trnL) %>%
     str_split(' voucher| isolate| culture| specimen| clone| bio-material') %>% 
     lapply('[[', 1) %>% 
     unlist()

names(ncbi.trnL) <- 
     names(ncbi.trnL) %>%
     str_split(' complete| partial') %>% 
     lapply('[[', 1) %>% 
     unlist()

names(ncbi.trnL) <- 
     names(ncbi.trnL) %>%
     str_split(' tRNA-| trnL-trnF| trnL gene| genes| trnT-trnL| trnF-trnL') %>% 
     lapply('[[', 1) %>% 
     unlist()

# Cultivar information not included in NCBI taxonomy look-up, and we could still pull this from accession number if desired
names(ncbi.trnL) <- 
     names(ncbi.trnL) %>%
     str_split(' cultivar') %>% 
     lapply('[[', 1) %>% 
     unlist()
```

There are a few exceptions not caught by these patterns, try to ID from names that are >2 words long
```{r}
names(ncbi.trnL)[grep('(\\S+\\s){3,}', names(ncbi.trnL))] %>% 
     sort()
```

Checked, and those with names of format Genus sp. [number] do look up correctly in NCBI taxonomy; so leave these.
```{r}
# Correct others
names(ncbi.trnL)[names(ncbi.trnL) == '>AY266228.1 Solanum quitoense LB747'] <- 
     '>AY266228.1 Solanum quitoense'

names(ncbi.trnL)[names(ncbi.trnL) == '>AY266240.1 Solanum melongena RGO244'] <- 
     '>AY266240.1 Solanum melongena'

names(ncbi.trnL)[names(ncbi.trnL) == '>AY266243.1 Solanum quitoense LB996'] <- 
     '>AY266243.1 Solanum quitoense'

names(ncbi.trnL)[names(ncbi.trnL) == '>LC568778.1 Prunus grayana FN170'] <- 
     '>LC568778.1 Prunus grayana'

names(ncbi.trnL)[names(ncbi.trnL) == '>LC637551.1 Piper sarmentosum Chiang Mai University, Faculty of Pharmacy:PSCM251220201'] <- 
     '>LC637551.1 Piper sarmentosum'
```

## Combine

```{r}
trnL <- c(ncbi.trnL, refseq.trnL)
trnL
```

Now we need to do some cleaning:
* Sequences that are the same and that come from the same species can be de-duplicated
* Sequences that are different and come from the same species must be preserved

```{r}
# Convert to dataframe to preserve information side-by-side
seqs <- 
     data.frame(name = names(trnL),
                seq = as.character(trnL)) %>% 
     separate(name,
              into = c('accession', 'name'),
              sep = ' ',
              extra = 'merge') %>% 
     mutate(accession = gsub('>', '', accession))

seqs
```
Now, we want to only keep distinct sequences from the same species

```{r}
seqs %>% 
     group_by(name, seq)
```
```{r}
dups <- 
     seqs %>% 
     group_by(name) %>% 
     summarize(n = sum(duplicated(seq)))

arrange(dups, desc(n))
```
```{r}
sum(dups$n)
```

So the number of sequences we expect after filtering is 
```{r}
dim(seqs)[1] - sum(dups$n)
```

```{r}
seqs <- 
     seqs %>%
     group_by(name, seq) %>% 
     arrange(accession) %>% 
     summarize(accession = first(accession)) # Choose the first accession number
```

Note that the caveat in this is that I've done a really permissive query of species not represented in RefSeq (pulling from all NCBI), but a one-off look for species that *are* in RefSeq.  This is imbalanced and I think would be good to reconcile.

```{r}
# Sort alphabetically
seqs <- arrange(seqs, name)

# Convert back to DNAStringSet object
trnL <- seqs$seq
names(trnL) <- paste(seqs$accession, seqs$name)

trnL <- DNAStringSet(trnL)
trnL
```

```{r}
# Save to file
writeXStringSet(trnL,
                here('data', 
                     'processed',
                     'dada2-compatible',
                     'trnL',
                     'trnLGH_update.fasta'))
```


