---
title: "trnL reference"
output: 
     html_document:
          df_print: paged
          toc: true
          toc_float: true
---

Stepping through this notebook will build a *trnL* reference database, trimmed to sequences amplified by the desired primer set (here, *trnL*g and *trnL*h).

This notebook use 

```{r libraries, include=FALSE, echo=FALSE}
library(Biostrings)
library(here)
library(ShortRead) # for clean()
library(taxonomizr) # for NCBI accession lookup
library(tidyverse)

source(here('code', 'functions', 'find_primer_pair.R'))
source(here('code', 'functions', 'query_ncbi.R'))
```

```{r plotting, include=FALSE, echo=FALSE}
theme_set(theme_bw() +
               theme(
                    axis.text = element_text(size = 12),
                    axis.title = element_text(size = 14,
                                              face = 'bold'),
                    legend.title = element_text(size = 12,
                                                face = 'bold'),
                    strip.text = element_text(size = 12,
                                              face = 'bold')
                     )
)
```

# Read in data 

```{r}
# Primer sequences 
trnLG <- DNAString('GGGCAATCCTGAGCCAA')
trnLH <- DNAString('CCATTGAGTCTCTGCACCTATC')

primers <- list(trnLG, trnLH)
```

```{r}
# Manually curated list of dietary and medicinal plants
plants <- 
     here('data', 'inputs', 'human-foods.csv') |>
     read.csv(stringsAsFactors = FALSE) |>
     filter(category == 'plant') |> 
     pull(scientific_name)

length(plants)
head(plants)
tail(plants)
```

```{r}
# Manual edits
edits <- 
     here('data', 'inputs', 'Manual renaming.csv') |> 
     read_csv() 

edits
```

# Submit query

## RefSeq (local)

```{r}
# Write to file
plastid <- 
     readDNAStringSet(
          here('data', 
               'outputs', 
               'parsed-refs',
               'RefSeq',
               'refseq_plastid_species.fasta'))

plastid
```
### Find primers

```{r}
# Note that there are lots of sequences that include Ns
length(plastid)
length(clean(plastid))
```

```{r}
refseq.trnL <- find_primer_pair(plastid, 
                                fwd = primers[[1]],
                                rev = primers[[2]])

cat(length(refseq.trnL), 'sequences have the primer set')
```

### Subset to foods

Just doing this by a simple grep for now
Could imagine it would be cleaner to process RefSeq to a comparable name as in our query
Keep accessions from raw files, look up taxonomy, then assign a "lowest level" name that would correspond to entries in human-foods.txt.

```{r}
# Find indices of entries matching 
plants.i <- 
     lapply(plants, grep, x = names(refseq.trnL)) %>%
     unlist()

cat('There are', length(plants), 'food plants in our query\n')

# Subset
refseq.trnL <- refseq.trnL[plants.i]
cat(length(refseq.trnL), 'have a trnL sequence in the RefSeq plastid database')
```

```{r}
# Strip name to only NCBI accession
names(refseq.trnL) %>% head()

names(refseq.trnL) <- 
     gsub(names(refseq.trnL),
          pattern = ' .*$',
          replacement = '')

head(names(refseq.trnL))
```
## NCBI (remote)

```{r}
# Pull sequences from NCBI
ncbi.trnL <- query_ncbi(marker = 'trnL',
                        organisms = plants)
```

This is from the total number of available sequences

```{r}
length(ncbi.trnL)
length(clean(ncbi.trnL))
```

### Find primers
Now look for primer binding sites within retrieved sequences.

```{r}
ncbi.trnL <- find_primer_pair(ncbi.trnL, 
                              fwd = primers[[1]],
                              rev = primers[[2]])

cat(length(ncbi.trnL), 'sequences have the primer set')
```

```{r}
# Note some entries are marked as unverified
names(ncbi.trnL)[grepl('UNVERIFIED', names(ncbi.trnL))] |> 
     head(5)

# Remove 
length(ncbi.trnL)
ncbi.trnL <- ncbi.trnL[!(grepl('UNVERIFIED', names(ncbi.trnL)))]
length(ncbi.trnL)
```
Want to convert these long, descriptive names to just an accession and taxon. Strip to accession number, and then use this to do a taxonomic lookup.

```{r}
# Strip name to only NCBI accession
names(ncbi.trnL) |> head()
names(ncbi.trnL) <- 
     names(ncbi.trnL) |> 
     gsub(pattern = ' .+$', replacement = '') |> 
     gsub(pattern = '^>', replacement = '')

head(names(ncbi.trnL))
```

## Combine

### Check overlap

```{r}
length(refseq.trnL)
length(ncbi.trnL)
```

```{r}
# Named as accession numbers:
intersect(names(ncbi.trnL), names(refseq.trnL)) |> length()
setdiff(names(refseq.trnL), names(ncbi.trnL)) |> length()
setdiff(names(ncbi.trnL), names(refseq.trnL)) |> length()
```
### Merge
```{r}
# Data frame of results
seqs.df <- 
     data.frame(source = 'RefSeq',
                accession = names(refseq.trnL),
                seq = as.character(refseq.trnL))

seqs.df <- 
     data.frame(source = 'GenBank',
                accession = names(ncbi.trnL),
                seq = as.character(ncbi.trnL)) |> 
     bind_rows(seqs.df)

head(seqs.df)
```

```{r}
missing <- plants[!(plants %in% seqs.df$taxon)]
length(plants)
length(missing)
```

### Taxonomy

```{r}
# Look up accession taxonomy using taxonomizr-formatted SQL database
ids <- taxonomizr::accessionToTaxa(seqs.df$accession, sql)
```

```{r}
# Any names missing?
any(is.na(ids))
sum(is.na(ids))
```

```{r}
# Which ones?
seqs.df[is.na(ids), c('source', 'accession')]
```

Missing entries are sequence records that have been added to NCBI in the time between making the taxonomic SQL file and now.  

As of Apr 2023 this includes tomatillo, bitter bean, turkey berry, hyacinth berry, and hairy-fruited eggplant

```{r}
# Remove these before proceeding
seqs.df <- seqs.df[!is.na(ids),]
ids <- ids[!is.na(ids)]
```

```{r}
taxonomy.raw <- taxonomizr::getRawTaxonomy(ids, sql)
```

```{r}
# Pull desired levels from this structure
# Not working within getTaxonomy function
vars <- c("superkingdom", 
          "phylum", 
          "class", 
          "order", 
          "family", 
          "genus",
          "species",
          "subspecies",
          "varietas",
          "forma")

taxonomy <- data.frame(superkingdom = NULL,
                       phylum = NULL,
                       class = NULL,
                       order = NULL,
                       family = NULL,
                       genus = NULL,
                       species = NULL,
                       subspecies = NULL,
                       varietas = NULL,
                       forma = NULL)

for (i in seq_along(taxonomy.raw)){
     row.i <- 
          taxonomy.raw[[i]] |> 
          t() |> 
          data.frame() 
     
     # Pick columns we're interested in
     shared <- intersect(vars, names(row.i))
     row.i <- select(row.i, one_of(shared))
     
     taxonomy <- bind_rows(taxonomy, row.i)
}

# Add taxon ID
taxonomy$taxid <- 
     names(taxonomy.raw) |> 
     trimws() |> 
     as.integer()

taxonomy <- select(taxonomy, taxid, everything())
```

```{r}
head(taxonomy)
```

```{r}
# Join back to accession
nrow(taxonomy) == nrow(seqs.df)

data.frame(taxid = ids) |> 
     full_join(distinct(taxonomy))
dim(taxonomy)
```

### Manual edits

There are two types of edits we're making:
     - **omissions**: High likelihood an included sequence has an incorrect taxon label, so we exclude it, and
     - **renaming**: The labeled taxon name can be specified more precisely (currently, happens only for *B. oleracea* spp.)

```{r}
edits
```

```{r}
# Handle omissions
omit <- filter(edits, type=='omit')

seqs.df <- 
     filter(seqs.df, 
            !(accession %in% omit$accession & seq %in% omit$sequence))
```

```{r}
# Handle renaming 
name.update <- filter(edits, type=='rename')

filter(seqs.df,
       accession %in% name.update$accession)
```


#### QC

Check for common errors

```{r}
# Check for degenerate nucleotide characters
grep('[AGCT]*[^AGCT]+', seqs.df$seq)
```

```{r}
# Add a flag to these taxa, to see if there's a back-up sequence
seqs.df$N <- grepl('[AGCT]*[^AGCT]+', seqs.df$seq)

with_n <- 
     seqs.df$taxon[grepl('[AGCT]*[^AGCT]+', seqs.df$seq)] |> 
     unique()
```

```{r}
seqs.df |> 
     filter(taxon %in% with_n) |> 
     group_by(taxon, N) |> 
     count() |> 
     ungroup() |> 
     group_by(taxon) |> 
     summarize(any(!N))
```
Okay, so for all taxa but
- Amaranthus cruentus
- Amaranthus dubius
- Costus erythrophyllus
- Vaccinium tenellum
- Victoria amazonica

we are covered by a second sequence. 

```{r}
# Remove sequences containing Ns
seqs.df <- 
     filter(seqs.df,
            !grepl(pattern = '[AGCT]*[^AGCT]+', seq))
```

####  Get reads in same orientation

```{r}
# Get orientation of sequence by finding primers
# How many mismatches are allowed?
fwd_err <- floor(0.2*length(trnLG))
rev_err <- floor(0.2*length(trnLH))

fwd_err
rev_err
```

```{r}
ref <- DNAStringSet(seqs.df$seq)
names(ref) <- paste(seqs.df$accession, seqs.df$taxon)
```

```{r}
# Forward primer at start of read
fwd_matches <- 
     vmatchPattern(trnLG, 
                   ref, 
                   max.mismatch = fwd_err,
                   fixed = TRUE) |>
     as.data.frame() |> 
     filter(start <= 1) |> 
     mutate(type = 'forward') |> 
     select(group, type)

# Reverse primer at start of read
rev_matches <- 
     vmatchPattern(trnLH, 
                   ref, 
                   max.mismatch = rev_err,
                   fixed = TRUE) |>
     as.data.frame() |> 
     filter(start <= 1) |> 
     mutate(type = 'reverse') |> 
     select(group, type)
```

```{r}
nrow(rev_matches) + nrow(fwd_matches) == nrow(seqs.df)
```

```{r}
seqs.df <- 
     bind_rows(fwd_matches,
          rev_matches) |> 
     arrange(group) |> 
     bind_cols(seqs.df)

seqs.df |> 
     group_by(type) |> 
     count()
```
Now, if a read is reversed, we want to replace it with its reverse complement
```{r}
seqs.df <- 
     mutate(seqs.df,
            seq = ifelse(type == 'reverse',
                         yes = seq |> 
                              DNAStringSet() |> 
                              reverseComplement() |> 
                              as.character(),
                         no = seq)) |> 
     select(-c(type, group))
```

#### Clean results

* Sequences that are the same and that come from the same species can be de-duplicated
* Sequences that are different and come from the same species must be preserved

```{r}
seqs.df |> 
     group_by(taxon, seq)
```
```{r}
dups <- 
     seqs.df |> 
     group_by(taxon) |> 
     summarize(n = sum(duplicated(seq)))

arrange(dups, desc(n))
```
```{r}
sum(dups$n)
```

So the number of sequences we expect after filtering is 
```{r}
dim(seqs.df)[1] - sum(dups$n)
```

```{r}
seqs.df <- 
     seqs.df |>
     group_by(taxon, seq) |> 
     arrange(acc) |> 
     summarize(acc = first(acc)) # Choose the first accession number

dim(seqs.df)
```

## Save

### DADA2
```{r}
# Sort alphabetically (first by species name, and then accession number)
seqs.df <- arrange(seqs.df, 
                   taxon,
                   acc)

# Convert back to DNAStringSet object
trnL <- seqs.df$seq
names(trnL) <- paste(seqs.df$acc, seqs.df$taxon)

trnL <- DNAStringSet(trnL)
trnL
```
```{r}
# Save to file
# Consider updating name below so I can compare to prior file
# writeXStringSet(trnL,
#                 here('data',
#                      'processed',
#                      'dada2-compatible',
#                      'trnL',
#                      'trnLGH.fasta'))
```

```{r}
seqs.df <- 
     seqs.df |> 
     unite(col = 'name',
           superkingdom:forma,
           sep = ';') 

names(trnL) <- seqs.df$name
```

```{r}
# writeXStringSet(trnL,
#                 here('data',
#                      'outputs',
#                      'dada2-compatible',
#                      'trnL',
#                      'trnLGH_taxonomy.fasta'))
```

### QIIME2 

Taxonomic assignment in QIIME2 with `classify-consensus-vsearch` requires two files:
- `i-reference-reads`, a QIIME artifact containing a FASTA file of sequences identified by their accession
- `i-reference-taxonomy`, a QIIME artifact containing a TSV (tab-separated value) file with two columns: "Feature ID", the same accessions, and "Taxon", the taxonomic lineage with ranks separated by semicolons

```{r}
outdir <- here('data',
               'outputs',
               'qiime2-compatible')

Sys.setenv(QIIME2 = outdir)
```

Note that QIIME2 requires that the FASTA file have unique accessions, so make these unique before proceeding

```{r}
seqs.df <- mutate(seqs.df,
                  acc = make.unique(acc,
                                    sep = '_'))

names(trnL) <- seqs.df$acc
# writeXStringSet(trnL,
#                 file.path(outdir,
#                           'trnL-sequences.fasta'))
```

```{r}
# seqs.df |>
#      select(`Feature ID` = acc,
#             Taxon = name) |>
#      write_delim(delim = '\t',
#                  file.path(outdir,
#                            'trnL-taxonomy.tsv'))
```

```{bash engine.opts='-l'}
# Running this block requires a QIIME2 conda environment on local machine
# Note that yours may differ from the "qiime2-2022.8"; you can find correct name by running conda env list in the terminal
# Convert both of the above objects to QIIME2 artifacts (QZA)
cd "$QIIME2"
conda activate qiime2-2022.8 

qiime tools import \
     --input-path trnL-sequences.fasta \
     --output-path trnL-sequences.qza \
     --type 'FeatureData[Sequence]'
     
qiime tools import \
     --input-path trnL-taxonomy.tsv \
     --output-path trnL-taxonomy.qza \
     --type 'FeatureData[Taxonomy]'
```

